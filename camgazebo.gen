/*/
 * Copyright (c) 2020 LAAS/CNRS
 * All rights reserved.
 *
 * Redistribution  and  use  in  source  and binary  forms,  with  or  without
 * modification, are permitted provided that the following conditions are met:
 *
 *   1. Redistributions of  source  code must retain the  above copyright
 *      notice and this list of conditions.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice and  this list of  conditions in the  documentation and/or
 *      other materials provided with the distribution.
 *
 * THE SOFTWARE  IS PROVIDED "AS IS"  AND THE AUTHOR  DISCLAIMS ALL WARRANTIES
 * WITH  REGARD   TO  THIS  SOFTWARE  INCLUDING  ALL   IMPLIED  WARRANTIES  OF
 * MERCHANTABILITY AND  FITNESS.  IN NO EVENT  SHALL THE AUTHOR  BE LIABLE FOR
 * ANY  SPECIAL, DIRECT,  INDIRECT, OR  CONSEQUENTIAL DAMAGES  OR  ANY DAMAGES
 * WHATSOEVER  RESULTING FROM  LOSS OF  USE, DATA  OR PROFITS,  WHETHER  IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR  OTHER TORTIOUS ACTION, ARISING OUT OF OR
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *                                                  Martin Jacquet - June 2020
 */
/* ---- Includes ---------------------------------------------------------- */
#pragma require "openrobots2-idl >= 2.0"

#include "or/time/time.idl"
// #include "or/sensor/camera.gen"
#include "camera.gen"

/* ---- Component declaration --------------------------------------------- */
component camgazebo {
    version         "1.0";
    email           "martin.jacquet@laas.fr";
    lang			"c";
    require         "genom3 >= 2.99.26";
    codels-require  "gazebo";

    provides or_camera;

    exception e_mem { string<128> what; };

    ids {
        boolean record;
        boolean display;

        or_camera::info info;
        or_camera::pipe pipe;

        float hfov;
        unsigned short w;
        unsigned short h;
    };

    const unsigned short pub_period_ms = 17;

    task main {
        period pub_period_ms ms;

        codel<start> camgz_start(out ::ids, out frame, out extrinsics, out intrinsics)
            yield wait;

        codel<wait> camgz_wait(in info.started)
            yield pause::wait, pub;

        codel<pub> camgz_pub(in h, in w, out frame)
            yield pause::wait;
    };

    /* ---- Hardware connection ------------------------------------------- */

    activity connect(in string<64> world = : "name of gazebo world",
                     in string<64> model = : "gazebo model containing the sensor",
                     in string<64> link = : "gazebo link containing the sensor",
                     in string<64> sensor = : "name of the gazebo sensor") {
        task main;

        codel<start> camgz_connect(in world, in model, in link, in sensor, out pipe, out intrinsics, out info.started)
            yield ether;
    };

    function disconnect() {
        codel camgz_disconnect(out info.started);
    };

    /* ---- Display/Record ------------------------------------------------ */

    // activity display() {
    //     task publish;
    //
    //     codel<start> camgz_disp_start()
    //         yield disp;
    //
    //     codel<disp> camgz_disp()
    //         yield pause::disp, stop;
    //
    //     codel<stop> camgz_disp_stop()
    //         yield ether;
    // };
    //
    // function stop_display() {
    //     codel camgz_stop_display();
    // };
    //
    // activity record(in string<64> path = "/tmp/": "Video files path") {
    //     task publish;
    //
    //     codel<start> camgz_rec_start()
    //         yield rec;
    //
    //     codel<rec> camgz_rec()
    //         yield pause::rec, stop;
    //
    //     codel<stop> camgz_rec_stop()
    //         yield ether;
    // };
    //
    // function stop_record() {
    //     codel camgz_stop_record();
    // };

    /* ---- Calibration --------------------------------------------------- */

    activity set_extrinsics(in sequence<double,6> ext_values) {
        task main;

        codel<start> camgz_set_extrinsics(in ext_values, out extrinsics)
            yield ether;
    };

    activity set_hfov(in float hfov_val = 1.047 : "Camera horizon FOV (in radians)") {
        task main;

        codel<start> camgz_set_hfov(in hfov_val, out hfov, in h, in w, out intrinsics)
            yield ether;
    };

    activity set_format(in unsigned short w_val = 1920 : "Camera pixel width",
                        in unsigned short h_val = 1080 : "Camera pixel height") {
        task main;
            codel<start> camgz_set_fmt(in w_val, out w, in h_val, out h, in hfov, out intrinsics)
                yield ether;
    };

    activity set_disto(in sequence<double,5> dist_values) {
        task main;

        codel<start> camgz_set_disto(in dist_values, out intrinsics)
            yield ether;
    };
};
